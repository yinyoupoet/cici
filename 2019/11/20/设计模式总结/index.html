<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>设计模式总结 | yinyoupoet的博客</title><meta name="description" content="精要论述23种设计模式，并进行融会贯通。"><meta name="keywords" content="设计模式"><meta name="author" content="yinyoupoet"><meta name="copyright" content="yinyoupoet"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="canonical" href="https://yinyoupoet.github.io/2019/11/20/设计模式总结/"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:title" content="设计模式总结"><meta name="twitter:description" content="精要论述23种设计模式，并进行融会贯通。"><meta name="twitter:image" content="https://yinyoupoet.github.io/images/cover&amp;top/软件体系结构.png"><meta property="og:type" content="article"><meta property="og:title" content="设计模式总结"><meta property="og:url" content="https://yinyoupoet.github.io/2019/11/20/设计模式总结/"><meta property="og:site_name" content="yinyoupoet的博客"><meta property="og:description" content="精要论述23种设计模式，并进行融会贯通。"><meta property="og:image" content="https://yinyoupoet.github.io/images/cover&amp;top/软件体系结构.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="next" title="Wireless Network Evolution - 6G &amp; AI" href="https://yinyoupoet.github.io/2019/11/05/Wireless-Network-Evolution-6G-AI/"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.js" defer></script><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?19446aca39e2fe294709670cbf706533";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script><meta name="google-site-verification" content><meta name="baidu-site-verification" content><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"207CQUEWZA","apiKey":"e43d6394203388cf47dc525ade9c9210","indexName":"HexoBlog","hits":{"per_page":6},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容:${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://yinyoupoet.github.io/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  highlight_copy: 'true',
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: '添加书签',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天'

  
}</script></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#引言"><span class="toc-number">1.</span> <span class="toc-text"> 引言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#预备知识"><span class="toc-number">2.</span> <span class="toc-text"> 预备知识</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#设计模式总体介绍"><span class="toc-number">3.</span> <span class="toc-text"> 设计模式总体介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#创建型模式"><span class="toc-number">4.</span> <span class="toc-text"> 创建型模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#工厂方法模式"><span class="toc-number">4.1.</span> <span class="toc-text"> 工厂方法模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#抽象工厂模式"><span class="toc-number">4.2.</span> <span class="toc-text"> 抽象工厂模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#建造者模式"><span class="toc-number">4.3.</span> <span class="toc-text"> 建造者模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#原型模式"><span class="toc-number">4.4.</span> <span class="toc-text"> 原型模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#单例模式"><span class="toc-number">4.5.</span> <span class="toc-text"> 单例模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#结构型模式"><span class="toc-number">5.</span> <span class="toc-text"> 结构型模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#适配器模式"><span class="toc-number">5.1.</span> <span class="toc-text"> 适配器模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#桥接模式"><span class="toc-number">5.2.</span> <span class="toc-text"> 桥接模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#组合模式"><span class="toc-number">5.3.</span> <span class="toc-text"> 组合模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#装饰模式"><span class="toc-number">5.4.</span> <span class="toc-text"> 装饰模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#外观模式"><span class="toc-number">5.5.</span> <span class="toc-text"> 外观模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#享元模式"><span class="toc-number">5.6.</span> <span class="toc-text"> 享元模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代理模式"><span class="toc-number">5.7.</span> <span class="toc-text"> 代理模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考资料"><span class="toc-number">6.</span> <span class="toc-text"> 参考资料</span></a></li></ol></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(/images/cover&amp;top/软件体系结构.png)"><div id="page-header"><span class="pull-left"> <a class="blog_title" id="site-name" href="/">yinyoupoet的博客</a></span><div class="open toggle-menu pull-right"><div class="menu-icon-first"></div><div class="menu-icon-second"></div><div class="menu-icon-third"></div></div><div class="menu_mask"></div><span class="pull-right menus"><div class="mobile_author_icon"><img class="lozad" src="/img/avatar1.jpg" onerror="onerror=null;src='/img/friend_404.gif'"></div><div class="mobile_post_data"><div class="mobile_data_item text-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">12</div></a></div></div><div class="mobile_data_item text-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">10</div></a></div></div><div class="mobile_data_item text-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">7</div></a></div></div></div><hr><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a><a class="site-page" href="/gallery/"><i class="fa-fw fa fa-picture-o"></i><span> 相册</span></a><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a><a class="site-page" href="/categories/诗歌/"><i class="fa-fw fa fa-star-half-o"></i><span> 诗歌</span></a><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a><script>document.body.addEventListener('touchstart', function(){ });</script></div></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></span></div><div id="post-info"><div id="post-title"><div class="posttitle">设计模式总结</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2019-11-20<span class="post-meta__separator">|</span><i class="fa fa-history" aria-hidden="true"></i> 更新于 2019-11-24</time><span class="post-meta__separator mobile_hidden">|</span><span class="mobile_hidden"><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/软件开发/">软件开发</a></span><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">3.6k</span><span class="post-meta__separator">|</span><span>阅读时长: 11 分钟</span><span class="post-meta__separator">|</span><span>阅读量: </span><span id="busuanzi_value_page_pv"></span></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><h2 id="引言"><a class="markdownIt-Anchor" href="#引言"></a> 引言</h2>
<p>为避免软件危机，我们引入了软件工程学，而在软件工程学中，我们常面临的一个问题就是软件维护问题。软件维护涉及面很广，细化到代码编写方面，那便对代码规范有了要求，而设计模式则是一门面向编程规范的学问。在1995年，GoF（Gang of Four，四人组/四人帮）出版了《设计模式：可复用面向对象软件的基础》一书，提出了23种设计模式，而这也成了如今非常经典的软件设计与程序编写规范。在最近几年中，笔者已学过四遍了，算不上太多心得体会，但也多少有些收获，因此将其记录下来以备查阅。本文将对设计模式进行一个精要的讲解，所涉及内容不会太详细，小白慎入。（注：本文中部分文字和图片来自网络，参考资料统一列于文章最后，侵删）</p>
<h2 id="预备知识"><a class="markdownIt-Anchor" href="#预备知识"></a> 预备知识</h2>
<p>要学习设计模式，首先要会一门程序设计语言，以面向对象者入手为佳，本文以java来展开。其次，要会UML的类图，关于其网上资料很多，在此不做赘述。第三点，就是一些颇为经典的软件设计原则，这里将其列出并作简单介绍：</p>
<ul>
<li>单一职责原则：一个类只干一件事——低耦合，高内聚</li>
<li>开闭原则：对扩展开放，对修改关闭</li>
<li>里氏代换原则：能接受基类的地方必能接受子类</li>
<li>依赖倒转原则：依赖于抽象而非具体类——针对抽象编程</li>
<li>接口隔离原则：用多个专门的接口取代单个统一的接口——降低耦合</li>
<li>合成复用原则：多用组合/聚合，少用继承</li>
<li>迪米特法则：若两个类不彼此直接通信，则此二者不能直接发生作用，需引入第三个类</li>
</ul>
<h2 id="设计模式总体介绍"><a class="markdownIt-Anchor" href="#设计模式总体介绍"></a> 设计模式总体介绍</h2>
<p>如下图所示，设计模式一共可分为三类模式，分别是创建型模式、结构型模式、行为型模式。</p>
<table>
<thead>
<tr>
<th>范围目的</th>
<th><strong>创建型模式</strong></th>
<th><strong>结构型模式</strong></th>
<th><strong>行为型模式</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>类模式</strong></td>
<td>工厂方法模式</td>
<td>（类）适配器模式</td>
<td>解释器模式  <br>模板方法模式</td>
</tr>
<tr>
<td><strong>对象模式</strong></td>
<td>抽象工厂模式  <br>建造者模式  <br>原型模式 <br> 单例模式</td>
<td>（对象）适配器模式  <br>桥接模式  <br>组合模式 <br> 装饰模式  <br>外观模式  <br>享元模式 <br> 代理模式</td>
<td>职责链模式  <br>命令模式 <br> 迭代器模式 <br> 中介者模式 <br> 备忘录模式 <br> 观察者模式  <br>状态模式  <br>策略模式  <br>访问者模式</td>
</tr>
</tbody>
</table>
<p>各类模式的关系如下图所示：</p>
<p><img alt="模式关系图" data-src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/image-20191120190446121.png" class="lozad"></p>
<h2 id="创建型模式"><a class="markdownIt-Anchor" href="#创建型模式"></a> 创建型模式</h2>
<h3 id="工厂方法模式"><a class="markdownIt-Anchor" href="#工厂方法模式"></a> 工厂方法模式</h3>
<blockquote>
<p><strong>Factory Method Pattern</strong>: Define an interface for creating an object, but let subclasses decide which class to instantiate. Factory Method lets a class defer instantiation to subclasses.</p>
</blockquote>
<p><img alt="工厂方法模式" data-src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/image-20191120220805432.png" class="lozad"></p>
<p>将工厂和产品都抽象化了，但是具体的生产仍是由一个具体工厂生产一个具体产品。但是需要注意的是，一个具体工厂只生产一个具体产品，即一个工厂类只负责生产一类产品对象，这虽然符合了开闭原则，但是每增加一个产品时都需要新创建一个具体产品类和一个具体工厂类。</p>
<h3 id="抽象工厂模式"><a class="markdownIt-Anchor" href="#抽象工厂模式"></a> 抽象工厂模式</h3>
<p>工厂模式每个具体工厂只能生产一类对象，这在需要新增加产品类时会比较麻烦，因此抽象工厂模式中一个工厂类可以创建多类对象。</p>
<blockquote>
<p><strong>Abstract Factory Pattern</strong>: Provide an interface for creating families of related or dependent objects without specifying their concrete classes.</p>
</blockquote>
<p><img alt="抽象工厂模式" data-src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/image-20191120221832027.png" class="lozad"></p>
<p>譬如说某个具体工厂为海尔工厂，则其既可以生产海尔电视机，也可以生产海尔冰箱。当需要生产TCL的电视机和电冰箱时，只需添加对应的具体工厂和具体产品即可，但是如果需要添加一个新的产品，比如说海尔需要生产手机了，那么这时还得修改其对应的具体工厂，因此可以看出其对于开闭原则也不能很好地遵循。</p>
<h3 id="建造者模式"><a class="markdownIt-Anchor" href="#建造者模式"></a> 建造者模式</h3>
<p>建造者模式讲究一步一步创建一个产品，创建的步骤是相同的，但是创建的产品的类型却可以不同。</p>
<blockquote>
<p><strong>Builder Pattern</strong>: Separate the construction of a complex object from its representation so that the same construction process can create different representations.</p>
</blockquote>
<p><img alt="建造者模式" data-src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/image-20191120223344579.png" class="lozad"></p>
<p>客户类只需调用构造者类的<code>getResult</code>方法即可，根据具体类中每个部分的构建方式不同，<code>getResult</code>返回的内容也不同，譬如肯德基的套餐，不同的套餐都有食物和饮料，但每个套餐提供的食物和饮料的种类却是不同的。</p>
<p>增加新的具体构建者不需要修改现有代码，符合开闭原则。但是如果产品的内部变化较大，则会需要很多个具体构建者，会使得类的结构比较臃肿。</p>
<h3 id="原型模式"><a class="markdownIt-Anchor" href="#原型模式"></a> 原型模式</h3>
<p>原型模式说明白点就是对象的自我拷贝，返回一个和自己一模一样的对象，只需根据需求来设置深拷贝和浅拷贝即可。</p>
<blockquote>
<p><strong>Prototype Pattern</strong>: Specify the kind of objects to create using a prototypical instance, and create new objects by copying this prototype.</p>
</blockquote>
<p><img alt="原型模式" data-src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/image-20191120224228849.png" class="lozad"></p>
<h3 id="单例模式"><a class="markdownIt-Anchor" href="#单例模式"></a> 单例模式</h3>
<p>单例模式即为让类只能产生一个对象，无论谁来访问都只能访问到同一个对象。其原理就是将构造函数设置为私有函数，由一个公有静态接口来返回类的唯一实例。</p>
<blockquote>
<p><strong>Singleton Pattern</strong>: Ensure a class has only one instance and provide a global point of access to it.</p>
</blockquote>
<p><img alt="单例模式" data-src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/image-20191120224444809.png" class="lozad"></p>
<p>单例模式分为饿汉式和懒汉式，饿汉式即在类加载时就创建了这个类的唯一实例，而懒汉式则在外部第一次获取该类的对象时才创建对象，上图所示即为懒汉式。</p>
<p>使用单例模式的思路可以设计<em>有限多例模式</em>，在此不做赘述。</p>
<h2 id="结构型模式"><a class="markdownIt-Anchor" href="#结构型模式"></a> 结构型模式</h2>
<p>结构型模式讨论的是如何将类或对象结合在一起形成更大的结构，可以相应地分为类结构型模式和对象结构型模式。</p>
<h3 id="适配器模式"><a class="markdownIt-Anchor" href="#适配器模式"></a> 适配器模式</h3>
<p>顾名思义，一般电脑充电器都会自带一个电源适配器，以将220V的电压适配到电脑电源所能接受的电压。适配器模式亦然，一个现有类已经实现了一些能满足客户端所要求的功能，但提供的接口不符合客户的需求，比如接口名和客户要求的接口名不同，因此这时可以设计一个适配器程序，由客户端只需调用适配器中符合客户要求的接口，而在适配器内部则代替客户端去调用那个现有类的函数。</p>
<blockquote>
<p><strong>Adapter Pattern</strong>: Convert the interface of a class into another interface clients expect. Adapter lets classes work together that couldn’t otherwise because of incompatible interfaces.</p>
</blockquote>
<p><img alt="类适配器" data-src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/image-20191120225426230.png" class="lozad"></p>
<p><img alt="对象适配器" data-src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/image-20191120225441222.png" class="lozad"></p>
<p>适配器模式使得目标类与客户类解耦，使得这个调用过程成了透明的过程，也增加了程序的可扩展性与可维护性，即便修改了目标类的实现代码，或者干脆换了一个类作为目标类，也只需要修改适配器类的内部代码即可，而不需对客户类进行任何修改。但是往往一个适配器类只能为一个客户端类服务，这也在一定程度上会使得代码比较臃肿。</p>
<h3 id="桥接模式"><a class="markdownIt-Anchor" href="#桥接模式"></a> 桥接模式</h3>
<p>桥接模式用于一个物体有两个或更多不同类型的属性的时候，用于化全连接的乘法为两两组合的加法。听起来很抽象，那就举个栗子。比如要创建一个图形，形状上有圆形、矩形、三角形，颜色上有红色、绿色、蓝色，因此如果为每一种形状都提供一个单独的颜色的版本的话，就需要9种不同的类，而如果使用桥接模式，则只需要单独定义3种图形和3种颜色，即一共6种，这在更复杂的系统中能显著减少类的数量。</p>
<p>其设计思想如下图，上面为采用全连接的思想，而下面则采用的是桥接模式的思想。</p>
<p><img alt="桥接模式设计思想" data-src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/image-20191124155424510.png" class="lozad"></p>
<blockquote>
<p><strong>Bridge Pattern</strong>: Decouple an abstraction from its implementation so that the two can vary independently.</p>
</blockquote>
<p>桥接模式的类图如下：</p>
<p><img alt="桥接模式" data-src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/image-20191124160018001.png" class="lozad"></p>
<p>桥接模式提高了系统的可扩展性，扩展任何一个维度都不需要修改原有的系统，符合开闭原则，且其分离了抽象接口与其具体实现，使得具体类的实现对用户透明，但是其会增加系统的理解与设计难度，且要求抽象出系统中某两个单独变化的维度，因此其使用具有一定的局限性。</p>
<h3 id="组合模式"><a class="markdownIt-Anchor" href="#组合模式"></a> 组合模式</h3>
<p>组合模式包含两类对象，分别是容器对象和叶子对象，而其目的就是可以透明地处理容器对象和叶子对象。比如对于文件和文件夹的遍历等。</p>
<blockquote>
<p><strong>Composite Pattern</strong>: Compose objects into tree structures to represent part-whole hierarchies. Composite lets clients treat individual objects and compositions of objects uniformly.</p>
</blockquote>
<p><img alt="组合模式" data-src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/image-20191124164159949.png" class="lozad"></p>
<p>组合模式比较简单，就不多解释了，它分为透明组合模式和安全组合模式，透明组合模式是在抽象构建中声明所有要使用的操作，而安全组合模式中抽象构建中仅声明公有操作。</p>
<h3 id="装饰模式"><a class="markdownIt-Anchor" href="#装饰模式"></a> 装饰模式</h3>
<p>为一个类或对象增加行为，常采用的有继承和关联两种方法，然而继承的话，对现有类的扩充不能动态进行控制，而关联就不同，可以设计一个装饰类来按需求动态地扩充被嵌入对象的行为，因此装饰模式采用的是关联机制来对类进行扩充。</p>
<blockquote>
<p><strong>Decorator Pattern</strong>: Attach additional responsibilities to an object dynamically. Decorators provide a flexible alternative to subclassing for extending functionality.</p>
</blockquote>
<p><img alt="装饰模式" data-src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/image-20191124171952767.png" class="lozad"></p>
<p>需要注意的是，装饰类的接口与被装饰类的接口要保持一致，这样客户端在使用的时候才能在不修改接口的情况下调用装饰类的实现。装饰模式比使用继承更加灵活，而且也符合开闭原则、合成复用原则等。抽象模式可以分为透明模式和半透明模式，透明模式中用户完全针对抽象编程，这点作简单了解即可。</p>
<h3 id="外观模式"><a class="markdownIt-Anchor" href="#外观模式"></a> 外观模式</h3>
<p>外观模式为每一个子系统提供了一个对外通信的统一的接口（外观类），客户类只需知道这个接口即可，而具体的复杂的这个子系统的实现过程则由外观类去实现。其能显著降低系统复杂度，提高客户端使用的便捷性。</p>
<blockquote>
<p><strong>Facade Pattern</strong>: Provide a unified interface to a set of interfaces in a subsystem. Facade defines a higher-level interface that makes the subsystem easier to use.</p>
</blockquote>
<p><img alt="外观模式" data-src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/image-20191124174332372.png" class="lozad"></p>
<p>用外观模式举个例子，即定义一个总开关作为外观类，其提供打开和关闭两种操作，而打开或关闭开关时，其自动打开或关闭了电灯、冰箱、电视等一系列的开关，而作为客户而言，只需打开这一个开关，子系统（外观类）就能为客户做一系列复杂的操作，而这些操作对客户而言都是透明的。但是当新增子系统时，可能需要修改外观类或客户端的源代码，这违背了开闭原则。需要注意的是，外观类的用意是为子系统提供一个集中化和简化的管理接口，因此不要在外观类中为子系统添加新的行为，那是装饰模式才干的事。</p>
<h3 id="享元模式"><a class="markdownIt-Anchor" href="#享元模式"></a> 享元模式</h3>
<p>享元模式很好理解，它的目的就是实现对象的共享。试想在开发中，加入需要经常是用到某一个字符串，比如<code>s='abc'</code>，那么就可以将这个对象丢入对象池中，每次访问时都从对象池中将其取出即可，而不用在每次使用前都new一次，这样会造成内存空间的浪费。</p>
<p>根据对象信息的性质不同，可以将信息分为两类，一个为内部状态，这个是固定在享元对象中不会变的信息，即可以共享的信息，而外部状态则是会随着环境改变而改变的信息，即不可共享的部分。</p>
<blockquote>
<p><strong>Flyweight Pattern</strong>: Use sharing to support large numbers of fine-grained objects efficiently.</p>
</blockquote>
<p><img alt="享元模式" data-src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/image-20191124210912346.png" class="lozad"></p>
<p>享元模式支持大量细粒度对象的复用，能极大减小内存中对象的数量，当系统中有大量对象且这些对象消耗大量内存、且这些对象的状态大部分可以外部化时，享元模式能起到很显著的作用。</p>
<h3 id="代理模式"><a class="markdownIt-Anchor" href="#代理模式"></a> 代理模式</h3>
<p>当客户端与目标对象之间不能直接通信时，往往采用代理模式，定义一个代理对象作为中介，根据实际需求为去掉一些客户不能看到的内容或者添加一些用户需要的额外服务，也包括数据加密等等。</p>
<blockquote>
<p><strong>Proxy Pattern</strong>: Provide a surrogate or placeholder for another object to control access to it.</p>
</blockquote>
<p><img alt="代理模式" data-src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/image-20191124211448973.png" class="lozad"></p>
<p>代理模式能协调客户端和目标程序之间的通信，并对其数据进行加工处理，在一定程度上降低了系统的耦合度，但是因为添加了一个代理，因此代理在进行数据处理时往往会耗费一些额外的时间，而比如远程代理，更是会带来一些额外的通信时延，且有的代理模式的实现也较为复杂。</p>
<hr>
<h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2>
<ul>
<li><a href="https://www.cnblogs.com/chenssy/p/3357683.html" target="_blank" rel="noopener">设计模式总结</a></li>
<li><a href="http://c.biancheng.net/design_pattern/" target="_blank" rel="noopener">Java设计模式：23种设计模式全面解析（超级详细）</a></li>
<li><a href="https://blog.csdn.net/qq_41997479/article/details/86619024" target="_blank" rel="noopener">软件体系结构与设计模式——课程总体介绍（01-03）</a></li>
<li><a href="https://www.cnblogs.com/adamjwh/p/9070107.html" target="_blank" rel="noopener">简说设计模式——享元模式</a></li>
</ul>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">yinyoupoet</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://yinyoupoet.github.io/2019/11/20/设计模式总结/">https://yinyoupoet.github.io/2019/11/20/设计模式总结/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://yinyoupoet.github.io">yinyoupoet的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/设计模式/">设计模式    </a></div><div class="post_share"><div class="social-share" data-image="/images/cover&amp;top/软件体系结构.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-buttom"><i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lozad post-qr-code__img" src="/img/wechat.jpg"><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lozad post-qr-code__img" src="/img/alipay.jpg"><div class="post-qr-code__desc">支付宝</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="next-post pull-full"><a href="/2019/11/05/Wireless-Network-Evolution-6G-AI/"><img class="next_cover lozad" data-src="/images/cover&amp;top/6G&amp;AI.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>Wireless Network Evolution - 6G &amp; AI</span></div></a></div></nav><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div class="vcomment" id="vcomment"></div><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var notify = false == true ? true : false;
var verify = false == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;

window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'smlw3k69ARv8sUTG6eFamB4N-gzGzoHsz',
  appKey:'yVLgeliGFjJizUR920FTQkj2',
  placeholder:'说点什么吧',
  avatar:'monsterid',
  guest_info:guest_info,
  pageSize:'10',
  lang:'zh-cn',
  recordIP: true
});</script></div></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2019 By yinyoupoet</div><div class="framework-info"><span>驱动 </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly"><span>Butterfly</span></a></div><div class="footer_custom_text">玻璃晴朗，橘子辉煌</div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><section class="rightside" id="rightside"><a id="to_comment" href="#post-comment"><i class="scroll_to_comment fa fa-comments"></i></a><i class="fa fa-book" id="readmode" title="阅读模式"> </i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换">繁</a><i class="fa fa-moon-o nightshift" id="nightshift" title="夜间模式"></i></section><div id="post_bottom"><div id="post_bottom_items"><a id="mobile_to_comment" href="#post-comment"><i class="mobile_scroll_to_comment fa fa-comments"></i></a><i class="fa fa-list" id="mobile_toc"></i><div id="toc_mobile"><div class="toc_mobile_headline">目录</div><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#引言"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text"> 引言</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#预备知识"><span class="toc_mobile_items-number">2.</span> <span class="toc_mobile_items-text"> 预备知识</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#设计模式总体介绍"><span class="toc_mobile_items-number">3.</span> <span class="toc_mobile_items-text"> 设计模式总体介绍</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#创建型模式"><span class="toc_mobile_items-number">4.</span> <span class="toc_mobile_items-text"> 创建型模式</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#工厂方法模式"><span class="toc_mobile_items-number">4.1.</span> <span class="toc_mobile_items-text"> 工厂方法模式</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#抽象工厂模式"><span class="toc_mobile_items-number">4.2.</span> <span class="toc_mobile_items-text"> 抽象工厂模式</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#建造者模式"><span class="toc_mobile_items-number">4.3.</span> <span class="toc_mobile_items-text"> 建造者模式</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#原型模式"><span class="toc_mobile_items-number">4.4.</span> <span class="toc_mobile_items-text"> 原型模式</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#单例模式"><span class="toc_mobile_items-number">4.5.</span> <span class="toc_mobile_items-text"> 单例模式</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#结构型模式"><span class="toc_mobile_items-number">5.</span> <span class="toc_mobile_items-text"> 结构型模式</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#适配器模式"><span class="toc_mobile_items-number">5.1.</span> <span class="toc_mobile_items-text"> 适配器模式</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#桥接模式"><span class="toc_mobile_items-number">5.2.</span> <span class="toc_mobile_items-text"> 桥接模式</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#组合模式"><span class="toc_mobile_items-number">5.3.</span> <span class="toc_mobile_items-text"> 组合模式</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#装饰模式"><span class="toc_mobile_items-number">5.4.</span> <span class="toc_mobile_items-text"> 装饰模式</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#外观模式"><span class="toc_mobile_items-number">5.5.</span> <span class="toc_mobile_items-text"> 外观模式</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#享元模式"><span class="toc_mobile_items-number">5.6.</span> <span class="toc_mobile_items-text"> 享元模式</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#代理模式"><span class="toc_mobile_items-number">5.7.</span> <span class="toc_mobile_items-text"> 代理模式</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#参考资料"><span class="toc_mobile_items-number">6.</span> <span class="toc_mobile_items-text"> 参考资料</span></a></li></ol></div></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/js-cookie@2/src/js.cookie.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script async src="/js/search/algolia.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css"><script>$(function () {
  $('span.katex-display').wrap('<div class="katex-wrap"></div>')
})</script><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="/js/third-party/fireworks.js"></script><script src="/js/nightshift.js"></script><script id="ribbon" src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/js/piao.js"></script><script src="/js/tw_cn.js"></script><script>translateInitilization()

</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@1.2.2/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script><script>const observer = lozad(); // lazy loads elements with default selector as '.lozad'
observer.observe();</script><div class="search-dialog" id="algolia-search"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>